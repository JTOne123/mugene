// Macro definitions for VSQ output support

// Usage:
//	- at beginning:
//		- set variables for DEFINE_SINGER operation.
//		- call VSQ_INITIALIZE_TRACK. DEFINE_SINGER is indirectly called.
//		- if it is the first singer track, call VSQ_SETUP_FIRST_TRACK
//		- then, call VSQ_SETUP_DONE.
//	- at finishing:
//		- call OUTPUT_VSQ_TEXT
//	- define vibrato using DEFINE_VIBRATO operation. Vibrato is referenced by definition index.
//	- write lyrics in raw Japanese (hiragana), it does not proceed timeline. They must be described only
//	  after vibrato definitions (to not confuse lyric consumption by note operations).
//	- write notes. Every note operation consumes one lyric.
//	- You can apply vibrato to the next note by @V operation. Reference it by definition index.
//	- Or you can also apply vibrato to every following note by @VV operation. (Reference by index too.)
//	- BPList  operations are:
//		- B : PitchBend
//		- D : Dynamics
//		- BRE : Breathiness
//		- BRI : Brightness
//		- C : Clearness
//		- H : Harmonics (valid only in Vocaloid1)
//		- XD : VibTrimDepth (valid only in Vocaloid1)
//		- G : Gender factor
//		- POR : Portamento Timing
//		- O : Opening
//	- NRPNs are supported as is; use NRPN and DTE operations. Or use some shorthand ones:
//		- BANK : language selection
//		- P : panpot
//		- V : volume
//		- VIB_RATE : vibrato rate
//		- VIB_DEPTH : vibrato depth
//		- PITCH_BEND_SENSITIVITY : pitch bend sensitivity
//		- @ : program change
//
// Implementation notes:
//
//	- The primary operations are "L" and "n".
//	  L defines a lyric handle, and n consumes a lyric to give a note.
//	  output. Both outputs a couple of meta texts and NRPN operations.
//	- Since both NRPNs from "L" and "n" should be actually unified to
//	  generate one note operation by the time NRPN(50,7F)=(7F,-) appears,
//	  this macro adds 1 step shifted (which should be almost harmess in
//	  480 base count) to make them consistent.
//

#basecount 1920


// NRPNs
#macro NRPNM val:number { CC #63,$val }
#macro NRPNL val:number { CC #62,$val }
#macro DTEM val:number { CC #06,$val }
#macro DTEL val:number { CC #26,$val }
#macro NRPNMP key,val { NRPNM $key DTEM $val }
#macro NRPNMPW key,msb,lsb { NRPNM $key DTE $msb,$lsb }
#macro NRPNLP key,val { NRPNL $key DTEM $val }
#macro NRPNLPW key,msb,lsb { NRPNL $key DTE $msb,$lsb }

#variable __version:number = 0
#variable __device:number = 0
#variable __delay:number = 0

#macro VER_DEV_DELAY_VAL msb,vmsb { \
	NRPN $msb,0 DTE $__version, $__device \
	NRPNLPW 1, $__delay % #80, $__delay / #80 \
	NRPNLP 2,$vmsb }
#macro BANK val:number { VER_DEV_DELAY_VAL #60,$val }
#macro V val:number { VER_DEV_DELAY_VAL #61,$val }
#macro P val:number { VER_DEV_DELAY_VAL #62,$val }
#macro VIB_RATE val:number { VER_DEV_DELAY_VAL #64,$val }
#macro VIB_DEPTH val:number { VER_DEV_DELAY_VAL #65,$val }
// FIXME: what is Effect2, which occupies #66?
#macro PITCH_BEND_SENSITIVITY val:number { VER_DEV_DELAY_VAL #67,$val }
#macro @ prog:number, lang:number=0 { BANK $lang NRPN #53,2 DTE $prog,0 }

// Buffer definitions
#variable EntireText:buffer
#variable Common:buffer
#variable MasterTrackSetup:buffer
#variable Events:buffer
#variable Defs:buffer
#variable Handles:buffer
#variable PitchBendBPList:buffer
#variable PitchBendSensBPList:buffer
#variable DynamicsBPList:buffer
#variable EpRResidualBPList:buffer
#variable EpRESlopeBPList:buffer
#variable EpRESlopeDepthBPList:buffer
#variable EpRSineBPList:buffer
// They are renamed from 1-4 to A-D as numbers are invalid as an identifier character.
#variable ResoAFreqBPList:buffer
#variable ResoBFreqBPList:buffer
#variable ResoCFreqBPList:buffer
#variable ResoDFreqBPList:buffer
#variable ResoABWBPList:buffer
#variable ResoBBWBPList:buffer
#variable ResoCBWBPList:buffer
#variable ResoDBWBPList:buffer
#variable ResoAAmpBPList:buffer
#variable ResoBAmpBPList:buffer
#variable ResoCAmpBPList:buffer
#variable ResoDAmpBPList:buffer
#variable VibTremDepthBPList:buffer
#variable GenderFactorBPList:buffer
#variable PortamentTimingBPList:buffer
#variable OpeningBPList:buffer

#macro VSQ_INITIALIZE_MASTER { TRACKNAME "Master Track" }

#macro SETUP_COMMON { __STORE {"Common", "[Common]", \
	"\nVersion=", $CommonVersion, "\nName=", $CommonName, \
	"\nColor=", $CommonColorRed, ",", $CommonColorGreen, ",", $CommonColorBlue, \
	"\nDynamicsMode=", $CommonDynamicsMode, "\nPlayMode=", $CommonPlayMode, "\n" } }

#variable MasterFeder, MasterPanpot, MasterMute, MasterOutputMode, MasterTracks:number=1
#macro VSQ_SETUP_FIRST_TRACK { __STORE {"MasterTrackSetup", "[Master]", "\nPreMeasure=4\n", \
	"[Mixer]", "\nMasterFeder=", $MasterFeder, "\nMasterPanpot=", $MasterPanpot, \
	"\nMasterMute=", $MasterMute, "\nOutputMode=", $MasterOutputMode, \
	"\nTracks=", $MasterTracks, "\n" } \
	}
#macro VSQ_SETUP_DONE { r1 r1 r1 r1}

#variable __tmp_position
#macro OUTPUT_VSQ_TEXT { \
	__LET {"__tmp_position", $__timeline_position } \
	__LET {"__timeline_position", 0 } \
	TRACKNAME $CommonName \
	SETUP_COMMON \
	__STORE { "EntireText", $Common, $MasterTrackSetup, "[EventList]\n", $Events, $Defs, $Handles \
		,$PitchBendBPList \
		,$PitchBendSensBPList \
		,$DynamicsBPList \
		,$EpRResidualBPList \
		,$EpRESlopeBPList \
		,$EpRESlopeDepthBPList \
		,$EpRSineBPList \
		,$ResoAFreqBPList \
		,$ResoBFreqBPList \
		,$ResoCFreqBPList \
		,$ResoDFreqBPList \
		,$ResoABWBPList \
		,$ResoBBWBPList \
		,$ResoCBWBPList \
		,$ResoDBWBPList \
		,$ResoAAmpBPList \
		,$ResoBAmpBPList \
		,$ResoCAmpBPList \
		,$ResoDAmpBPList \
		,$VibTremDepthBPList \
		,$GenderFactorBPList \
		,$PortamentTimingBPList \
		,$OpeningBPList \
		} \
	TEXT $EntireText \
	__LET {"__timeline_position", $__tmp_position } \
	}


#variable __handle_defs
#variable __handle_uses
#variable __events

// Singer definition ----
#variable IconID:string = "$07010000"
#variable IDS:string = "Miku"
#variable Original:number = 0
#variable Caption:string
#variable Length:number = 1
#variable Language:number = 0
#variable Program:number = 0
#variable CommonVersion:string = "DSB301"
#variable CommonName:string = "Voice1"
#variable CommonColorRed:number = 157
#variable CommonColorGreen:number = 181
#variable CommonColorBlue:number = 123
#variable CommonDynamicsMode:number = 1
#variable CommonPlayMode:number = 1

#macro SINGER_MIKU { \
	__LET {"IconID", "$07010000" } __LET {"IDS", "Miku" } __LET {"Original", 0} \
	__LET {"Language", 0 } __LET {"Program", 0 } __LET {"CommonVersion", "DSB301" } }
// FIXME: define SINGER_RIN, SINGER_LEN, SINGER_LUKA, SINGER_GAK, SINGER_MEG etc.

// relevant variables: $IconID, $IDS, $Original, $Caption, $Length, $Language, $Program
#macro DEFINE_SINGER { \
	__STORE { \
		"Handles", "[h#0000]\nIconID=", $IconID, "\nIDS=", $IDS, \
		"\nOriginal=", $Original, "\nCaption=", $Caption, "\nLength=", $Length, \
		"\nLanguage=", $Language, "\nProgram=", $Program, "\n" } \
	__STORE {"Events", "0=ID#0000\n"} \
	__STORE {"Defs", "[ID#0000]\nType=Singer\nIconHandle=h#0000\n"} \
	@ $Program, $Language \
	__LET { "__handle_defs", $__handle_defs + 1 } \
	__LET { "__handle_uses", $__handle_uses + 1 } \
	__LET { "__events", $__events + 1 } \
	}

#macro VSQ_INITIALIZE_TRACK { \
	__STORE {"PitchBendBPList", "[PitchBendBPList]\n"} \
	__STORE {"PitchBendSensBPList", "[PitchBendSensBPList]\n"} \
	__STORE {"DynamicsBPList", "[DynamicsBPList]\n"} \
	__STORE {"EpRResidualBPList", "[EpRResidualBPList]\n"} \
	__STORE {"EpRESlopeBPList", "[EpRESlopeBPList]\n"} \
	__STORE {"EpRESlopeDepthBPList", "[EpRESlopeDepthBPList]\n"} \
	__STORE {"EpRSineBPList", "[EpRSineBPList]\n"} \
	__STORE {"ResoAFreqBPList", "[Reso1FreqBPList]\n"} \
	__STORE {"ResoBFreqBPList", "[Reso2FreqBPList]\n"} \
	__STORE {"ResoCFreqBPList", "[Reso3FreqBPList]\n"} \
	__STORE {"ResoDFreqBPList", "[Reso4FreqBPList]\n"} \
	__STORE {"ResoABWBPList", "[Reso1BWBPList]\n"} \
	__STORE {"ResoBBWBPList", "[Reso2BWBPList]\n"} \
	__STORE {"ResoCBWBPList", "[Reso3BWBPList]\n"} \
	__STORE {"ResoDBWBPList", "[Reso4BWBPList]\n"} \
	__STORE {"ResoAAmpBPList", "[Reso1AmpBPList]\n"} \
	__STORE {"ResoBAmpBPList", "[Reso2AmpBPList]\n"} \
	__STORE {"ResoCAmpBPList", "[Reso3AmpBPList]\n"} \
	__STORE {"ResoDAmpBPList", "[Reso4AmpBPList]\n"} \
	__STORE {"VibTremDepthBPList", "[VibTremDepthBPList]\n"} \
	__STORE {"GenderFactorBPList", "[GenderFactorBPList]\n"} \
	__STORE {"PortamentTimingBPList", "[PortamentTimingBPList]\n"} \
	__STORE {"OpeningBPList", "[OpeningBPList]\n"} \
	DEFINE_SINGER \
	}

#define HANDLE_DEFS_COND {$__handle_defs \> 10000 ? "[h#{0:D08}]\n", "[h#{0:D04}]\n"}
#define HANDLE_USES_COND {$__handle_uses \> 10000 ? "h#{0:D08}\n", "h#{0:D04}\n"}
#variable tmp_phonLen, phonA, phonB, phonC
#macro L label:string, en:string, params:string, phonLen, phonA, phonB, phonC { \
	\// meta text
	__STORE_FORMAT {"Handles", HANDLE_DEFS_COND, $__handle_defs } \
	__STORE {"Handles", "L0=\"", $label, "\",\"", $en, "\",0.0000000,", $params, ",0\n"} \
	\// NRPNs (FIXME: they cannot be simply embedded at step 0.)
	__SAVE_OPER_BEGIN \
	NRPNM #50 NRPNLP #12,$phonLen NRPNLP #13,$phonA NRPNLP #14,$phonB NRPNLP #15,$phonC NRPNLP #4F,#7F \
	__SAVE_OPER_END $__handle_defs \
	__LET{"__handle_defs", $__handle_defs + 1} }
// lyric macros are defined later (they are bunch).

// Vibrato operations ----
#variable vibrato:number = 0
#variable vibrato_constant:number = 0

#macro DEFINE_VIBRATO \
	ids:string="normal", caption:string, original:number=1, startRate:number, \
	startDepth:number, len:number, depthBPNum:number=0, rateBPNum:number=0 { \
	__STORE_FORMAT {"Handles", HANDLE_DEFS_COND, $__handle_defs } \
	__STORE {"Handles", "IconID=$04040001", "\nIDS=", $ids, "\nOriginal=", $original, \
		"\nCaption=", $caption, "\nLength=", $len, "\nStartDepth=", $startDepth, \
		"\nDepthBPNum=", $depthBPNum, "\nStartRate=", $startRate, \
		"\nRateBPNum=", $rateBPNum, "\n"} \
	__LET {"__handle_defs", $__handle_defs + 1 } \
	__LET {"__handle_uses", $__handle_uses + 1 } \
	}

#macro @V id:number { __LET { "vibrato", $id } } // ID is the defined order.
#macro @VV id:number { __LET {"vibrato_constant", $id } @V $id }

// Note operations ----
#variable dynamics:number = 0
#variable pm_bend_depth:number = 0
#variable pm_bend_length:number = 0
#variable pmb_portament_use:number = 0
#variable dem_dec_gain_rate:number = 0
#variable dem_accent:number = 0
#variable handle_uses:number = 0
#macro AddVibratoHandle id:number { __STORE{"EventDefs", "VibratoHandle=", $id } }
#define EVENTS_COND { $__events \> 10000 ? "[ID#{0:D08}]\n", "[ID#{0:D04}]\n" }
#define EVENTS_APPLY_COND $__events \> 10000 ? "{0}=ID#{1:D08}\n", "{0}=ID#{1:D04}\n"
#macro n key:number, step:length, gate:length, vel:number=$__velocity { \
	__LET{"__current_note_step", {$gate + %1} ? $gate, $step}  \
	__LET{"__current_note_gate", {{$__current_note_step * $__gate_rel * {1 / $__gate_rel_denom}}} - $__gate_abs} \
	__LET{"__current_note_gate", $__current_note_gate \< 0 ? 0, $__current_note_gate } \
	__STORE_FORMAT {"Defs", EVENTS_COND, $__events } \
	__STORE { "Defs", "Type=Anote\nLength=", $__current_note_gate, "\nNote#=", $key, \
	"\nDynamics=", $dynamics, "\nPMBendDepth=", $pm_bend_depth, \
	"\nPMBendLength=", $pm_bend_length, "\nPMbPortamentUse=", \
	$pmb_portament_use, "\nDEMdecGainRate=", $dem_dec_gain_rate, \
	"\nDEMaccept=", $dem_accent, "\nLyricHandle=" } \
	__STORE_FORMAT {"Defs", HANDLE_USES_COND, $__handle_uses } \
	__APPLY {$vibrato ? "AddVibratoHandle", "NOP", $vibrato} \
	__LET {"vibrato", $vibrato_constant } \
	__STORE_FORMAT {"Events", EVENTS_APPLY_COND, $__timeline_position, $__events } \
	__LET { "__events", $__events + 1 } \
	\// NRPNs. FIXME: how to calculate "note location"?
	VER_DEV_DELAY_VAL#50,$key NRPNLP 3,$vel NRPNLP 4,$__current_note_gate NRPNLP 5,3 \
	DEBUG $handle_uses \
	__RESTORE_OPER $__handle_uses NRPNLP #7F,#7F \
	NOP $__current_note_step \
	__LET {"__handle_uses", $__handle_uses + 1 } \
	} // One note operation consumes one lyric handle

// BPLists ----
#macro BP_NRPN paraID,val { VER_DEV_DELAY #55,$paraID,0 NRPNLP 3,$val }

#variable __pitch_bend_bp:number
#macro B val:number { __LET { "__pitch_bend_bp", $val } __STORE { "PitchBendBPList", $__timeline_position, "=", $val, "\n" } \
	VER_DEV_DELAY #54, $val % #80, $val / #80 }
#macro B+ val:number { P $__pitch_bend_bp + $val }
#macro B_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "P", "P+", SPECTRA_ONESHOT_ARG_USE }

#variable __dynamics
#macro D val:number { __LET { "__dynamics", $val } \
	__STORE { "DynamicsBPList", $__timeline_position, "=", $val, "\n" } VER_DEV_DELAY #63,$val,0 }
#macro D+ val:number { D $__dynamics + $val }
#macro D_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "D", "D+", SPECTRA_ONESHOT_ARG_USE }

#variable __breathiness
#macro BRE val:number { __LET { "__breathiness", $val } \
	__STORE { "EpRResidualBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN31,$val }
#macro BRE+ val:number { BRE $__breathiness + $val }
#macro BRE_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "BRE", "BRE+", SPECTRA_ONESHOT_ARG_USE }

#variable __brightness
#macro BRI val:number { __LET { "__brightness", $val } \
	__STORE { "EpRESlopeBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN32,$val }
#macro BRI+ val:number { BRI $__brightness + $val }
#macro BRI_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "BRI", "BRI+", SPECTRA_ONESHOT_ARG_USE }

#variable __clearness
#macro C val:number { __LET { "__clearness", $val } \
	__STORE { "EpRESlopeDepthBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN33,$val }
#macro C+ val:number { C $__clearness + $val }
#macro C_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "C", "C+", SPECTRA_ONESHOT_ARG_USE }

// only in V1
#variable __harmonics
#macro H val:number { __LET { "__harmonics", $val } \
	__STORE { "EpRSineBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN30,$val }
#macro H+ val:number { H $__harmonics + $val }
#macro H_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "H", "H+", SPECTRA_ONESHOT_ARG_USE }

#variable __vib_trem_depth
// FIXME: no NRPNs to write?
#macro XD val:number { __LET { "__vib_trem_depth", $val } __STORE { "VibTremDepthBPList", $__timeline_position, "=", $val, "\n" } }
#macro XD+ val:number { XD $__vib_trem_depth + $val }
#macro XD_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "XD", "XD+", SPECTRA_ONESHOT_ARG_USE }

#variable __gender_factor
#macro G val:number { __LET { "__gender_factor", $val } \
	__STORE { "GenderFactorBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN70,$val }
#macro G+ val:number { G $__gender_factor + $val }
#macro G_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "G", "G+", SPECTRA_ONESHOT_ARG_USE }

#variable __portamento_timing
#macro POR val:number { __LET { "__portamento_timing", $val } \
	__STORE { "PortamentoTimingBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN34,$val }
#macro POR+ val:number { POR $__portamento_timing + $val }
#macro POR_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "POR", "POR+", SPECTRA_ONESHOT_ARG_USE }

#variable __opening
#macro O val:number { __LET { "__opening", $val } \
	__STORE { "OpeningBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN35,$val }
#macro O+ val:number { O $__opening + $val }
#macro O_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "O", "O+", SPECTRA_ONESHOT_ARG_USE }


// Lyrics macro ----
#macro あ { L "あ", "a", "0", 1, #61 }
#macro い { L "い", "i", "0", 1, #69 }
#macro う { L "う", "M", "0", 1, #4D }
#macro え { L "え", "e", "0", 1, #65 }
#macro お { L "お", "o", "0", 1, #6F }
#macro か { L "か", "k a", "64,0", 2, #6B, #61 }
#macro く { L "く", "k M", "64,0", 2, #6B, #4D }
#macro け { L "け", "k e", "64,0", 2, #6B, #65 }
#macro こ { L "こ", "k o", "64,0", 2, #6B, #6F }
#macro きゃ { L "きゃ", "k' a", "64,64,0", 3, #6B, #27, #61 }
#macro き   { L "き",   "k' i", "64,64,0", 3, #6B, #27, #69 }
#macro きゅ { L "きゅ", "k' M", "64,64,0", 3, #6B, #27, #4D }
#macro きぇ { L "きぇ", "k' e", "64,64,0", 3, #6B, #27, #65 }
#macro きょ { L "きょ", "k' o", "64,64,0", 3, #6B, #27, #6F }
#macro が { L "が", "g a", "64,0", 2, #67, #61 }
#macro ぐ { L "ぐ", "g M", "64,0", 2, #67, #4D }
#macro げ { L "げ", "g e", "64,0", 2, #67, #65 }
#macro ご { L "ご", "g o", "64,0", 2, #67, #6F }
#macro ぎゃ { L "ぎゃ", "g' a", "64,64,0", 3, #67, #27, #61 }
#macro ぎ   { L "ぎ",   "g' i", "64,64,0", 3, #67, #27, #69 }
#macro ぎゅ { L "ぎゅ", "g' M", "64,64,0", 3, #67, #27, #4D }
#macro ぎぇ { L "ぎぇ", "g' e", "64,64,0", 3, #67, #27, #65 }
#macro ぎょ { L "ぎょ", "g' o", "64,64,0", 3, #67, #27, #6F }
#macro さ { L "さ", "s a", "64,0", 2, #73, #61 }
#macro し { L "し", "S i", "64,0", 2, #53, #69 }
#macro す { L "す", "s M", "64,0", 2, #73, #4D }
#macro せ { L "せ", "s e", "64,0", 2, #73, #65 }
#macro そ { L "そ", "s o", "64,0", 2, #73, #6F }
#macro ざ { L "ざ", "z a", "64,0", 2, #7A, #61 }
#macro じ { L "じ", "Z i", "64,0", 2, #5A, #69 }
#macro ず { L "ず", "z M", "64,0", 2, #7A, #4D }
#macro ぜ { L "ぜ", "z e", "64,0", 2, #7A, #65 }
#macro ぞ { L "ぞ", "z o", "64,0", 2, #7A, #6F }
// for word-initiator
#macro _ざ { L "ざ", "dz a", "64,0", 3, #64, #7A, #61 }
#macro _ず { L "ず", "dz M", "64,0", 3, #64, #7A, #4D }
#macro _ぜ { L "ぜ", "dz e", "64,0", 3, #64, #7A, #65 }
#macro _ぞ { L "ぞ", "dz o", "64,0", 3, #64, #7A, #6F }
#macro _じゃ { L "じゃ", "dZ a", "64,64,0", 3, #64, #5A, #61 }
#macro _じ   { L "じ",   "dZ i", "64,64,0", 3, #64, #5A, #69 }
#macro _じゅ { L "じゅ", "dZ M", "64,64,0", 3, #64, #5A, #4D }
#macro _じぇ { L "じぇ", "dZ e", "64,64,0", 3, #64, #5A, #65 }
#macro _じょ { L "じょ", "dZ o", "64,64,0", 3, #64, #5A, #6F }
#macro た { L "た", "t a", "64,0", 2, #74, #61 }
#macro て { L "て", "t e", "64,0", 2, #74, #65 }
#macro と { L "と", "t o", "64,0", 2, #74, #6F }
#macro ちゃ { L "ちゃ", "tS a", "64,64,0", 3, #74, #53, #61 }
#macro ち   { L "ち",   "tS i", "64,64,0", 3, #74, #53, #69 }
#macro ちゅ { L "ちゅ", "tS u", "64,64,0", 3, #74, #53, #4D }
#macro ちぇ { L "ちぇ", "tS e", "64,64,0", 3, #74, #53, #65 }
#macro ちょ { L "ちょ", "tS o", "64,64,0", 3, #74, #53, #6F }
#macro つぁ { L "つぁ", "ts a", "64,64,0", 3, #74, #73, #61 }
#macro つぃ { L "つぃ", "ts i", "64,64,0", 3, #74, #73, #69 }
#macro つ   { L "つ",   "ts M", "64,64,0", 3, #74, #73, #4D }
#macro つぇ { L "つぇ", "ts e", "64,64,0", 3, #74, #73, #65 }
#macro つぉ { L "つぉ", "ts o", "64,64,0", 3, #74, #73, #6F }
#macro てゃ { L "てゃ", "t' a", "64,64,0", 3, #74, #27, #61 }
#macro てぃ { L "てぃ", "t' i", "64,64,0", 3, #74, #27, #69 }
#macro てゅ { L "てゅ", "t' M", "64,64,0", 3, #74, #27, #4D }
#macro てぇ { L "てぇ", "t' e", "64,64,0", 3, #74, #27, #65 }
#macro てょ { L "てょ", "t' o", "64,64,0", 3, #74, #27, #6F }
#macro だ   { L "だ",   "d a", "64,0", 2, #64, #61 }
#macro どぅ { L "どぅ", "d M", "64,0", 3, #64, #4D }
#macro で   { L "で",   "d e", "64,0", 2, #64, #65 }
#macro ど   { L "ど",   "d o", "64,0", 2, #64, #6F }
#macro でゃ { L "でゃ", "d' a", "64,64,0", 3, #64, #27, #61 }
#macro でぃ { L "でぃ", "d' i", "64,64,0", 3, #64, #27, #69 }
#macro でゅ { L "でゅ", "d' M", "64,64,0", 3, #64, #27, #4D }
#macro でぇ { L "でぇ", "d' e", "64,64,0", 3, #64, #27, #65 }
#macro でょ { L "でょ", "d' o", "64,64,0", 3, #64, #27, #6F }
#macro ぢ { じ }
#macro づ { ず }
#macro な { L "な", "n a", "64,0", 2, #6E, #61 }
#macro ぬ { L "ぬ", "n M", "64,0", 2, #6E, #4D }
#macro ね { L "ね", "n e", "64,0", 2, #6E, #65 }
#macro の { L "の", "n o", "64,0", 2, #6E, #6F }
#macro にゃ { L "にゃ", "J a", "64,0", 2, #4A, #61 }
#macro に   { L "に",   "J i", "64,0", 2, #4A, #69 }
#macro にゅ { L "にゅ", "J M", "64,0", 2, #4A, #4D }
#macro にぇ { L "にぇ", "J e", "64,0", 2, #4A, #65 }
#macro にょ { L "にょ", "J o", "64,0", 2, #4A, #6F }
// in-the-middle-of-words
#macro は { L "は", "h\\ a", "64,0", 3, #68, #5C, #61 }
#macro へ { L "へ", "h\\ e", "64,0", 3, #68, #5C, #65 }
#macro ほ { L "ほ", "h\\ o", "64,0", 3, #68, #5C, #6F }
#macro ひゃ { L "ひゃ", "C a", "64,0", 2, #43, #61 }
#macro ひ   { L "ひ",   "C i", "64,0", 2, #43, #69 }
#macro ひゅ { L "ひゅ", "C M", "64,0", 2, #43, #4D }
#macro ひぇ { L "ひぇ", "C e", "64,0", 2, #43, #65 }
#macro ひょ { L "ひょ", "C o", "64,0", 2, #43, #6F }
#macro ふぁ { L "ふぁ", "p\\ a", "64,64,0", 3, #70, #5C, #61 }
#macro ふ   { L "ふ",   "p\\ M", "64,64,0", 3, #70, #5C, #4D }
#macro ふぇ { L "ふぇ", "p\\ e", "64,64,0", 3, #70, #5C, #65 }
#macro ふぉ { L "ふぉ", "p\\ o", "64,64,0", 3, #70, #5C, #6F }
#macro ふゃ { L "ふゃ", "p\\' a", "64,64,64,0", 4, #70, #5C, #27, #61 }
#macro ふぃ { L "ふぃ", "p\\' i", "64,64,64,0", 4, #70, #5C, #27, #69 }
#macro ふゅ { L "ふゅ", "p\\' M", "64,64,64,0", 4, #70, #5C, #27, #4D }
// word-initiator
#macro _は { L "は", "h a", "64,0", 2, #68, #61 }
#macro _ひ { ひ }
#macro _ふぃ { ふぃ }
#macro _ふ { ふ }
#macro _へ { L "へ", "h e", "64,0", 2, #68, #65 }
#macro _ほ { L "ほ", "h o", "64,0", 2, #68, #6F }
#macro ば { L "ば", "b a", "64,0", 2, #62, #61 }
#macro ぶ { L "ぶ", "b M", "64,0", 2, #62, #4D }
#macro べ { L "べ", "b e", "64,0", 2, #62, #65 }
#macro ぼ { L "ぼ", "b o", "64,0", 2, #62, #6F }
#macro びゃ { L "びゃ", "b' a", "64,64,0", 3, #62, #27, #61 }
#macro び   { L "び",   "b' i", "64,64,0", 3, #62, #27, #69 }
#macro びゅ { L "びゅ", "b' M", "64,64,0", 3, #62, #27, #4D }
#macro びぇ { L "びぇ", "b' e", "64,64,0", 3, #62, #27, #65 }
#macro びょ { L "びょ", "b' o", "64,64,0", 3, #62, #27, #6F }
#macro ぱ { L "ぱ", "p a", "64,0", 2, #70, #61 }
#macro ぷ { L "ぷ", "p M", "64,0", 2, #70, #4D }
#macro ぺ { L "ぺ", "p e", "64,0", 2, #70, #65 }
#macro ぽ { L "ぽ", "p o", "64,0", 2, #70, #6F }
#macro ぴゃ { L "ぴゃ", "p' a", "64,64,0", 3, #70, #27, #61 }
#macro ぴ   { L "ぴ",   "p' i", "64,64,0", 3, #70, #27, #69 }
#macro ぴゅ { L "ぴゅ", "p' M", "64,64,0", 3, #70, #27, #4D }
#macro ぴぇ { L "ぴぇ", "p' e", "64,64,0", 3, #70, #27, #65 }
#macro ぴょ { L "ぴょ", "p' o", "64,64,0", 3, #70, #27, #6F }
#macro ま { L "ま", "m a", "64,0", 2, #6D, #61 }
#macro む { L "む", "m M", "64,0", 2, #6D, #4D }
#macro め { L "め", "m e", "64,0", 2, #6D, #65 }
#macro も { L "も", "m o", "64,0", 2, #6D, #6F }
#macro みゃ { L "み", "m' a", "64,64,0", 3, #6D, #27, #61 }
#macro み   { L "み", "m' i", "64,64,0", 3, #6D, #27, #69 }
#macro みゅ { L "み", "m' M", "64,64,0", 3, #6D, #27, #4D }
#macro みぇ { L "み", "m' e", "64,64,0", 3, #6D, #27, #65 }
#macro みょ { L "み", "m' o", "64,64,0", 3, #6D, #27, #6F }
#macro や { L "や", "j a", "64,0", 2, #6A, #61 }
#macro ゆ { L "ゆ", "j u", "64,0", 2, #6A, #75 }
#macro よ { L "よ", "j o", "64,0", 2, #6A, #6F }
#macro ら { L "ら", "4 a", "64,0", 2, #34, #61 }
#macro る { L "る", "4 M", "64,0", 2, #34, #4D }
#macro れ { L "れ", "4 e", "64,0", 2, #34, #65 }
#macro ろ { L "ろ", "4 o", "64,0", 2, #34, #6F }
#macro りゃ { L "りゃ", "4' a", "64,64,0", 3, #34, #27, #61 }
#macro り   { L "り",   "4' i", "64,64,0", 3, #34, #27, #69 }
#macro りゅ { L "りゅ", "4' M", "64,64,0", 3, #34, #27, #4D }
#macro りぇ { L "りぇ", "4' e", "64,64,0", 3, #34, #27, #65 }
#macro りょ { L "りょ", "4' o", "64,64,0", 3, #34, #27, #6F }
#macro わ { L "わ", "w a", "64,0", 2, #77, #61 }
#macro を { L "を", "o", "0", 1, #6F }
#macro ん { L "ん", "N \\", "64,64", 1, #4E, #5C }
// FIXME: are んま-んも defined differently? Or are they different in Luka?
