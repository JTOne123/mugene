// Macro definitions for VSQ output support

// Usage:
//	- at beginning:
//		- set variables for DEFINE_SINGER operation.
//		- call VSQ_INITIALIZE_TRACK. DEFINE_SINGER is indirectly called.
//	- at finishing:
//		- call OUTPUT_VSQ_TEXT
//	- define vibrato using DEFINE_VIBRATO operation. Vibrato is referenced by definition index.
//	- write lyrics in raw Japanese (hiragana), it does not proceed timeline. They must be described only
//	  after vibrato definitions (to not confuse lyric consumption by note operations).
//	- write notes. Every note operation consumes one lyric.
//	- You can apply vibrato to the next note by @V operation. Reference it by definition index.
//	- Or you can also apply vibrato to every following note by @VV operation. (Reference by index too.)
//	- BPList  operations are:
//		- P : PitchBend
//		- D : Dynamics
//		- BRE : Breathiness
//		- BRI : Brightness
//		- C : Clearness
//		- H : Harmonics (valid only in Vocaloid1)
//		- XD : VibTrimDepth
//		- G : Gender factor
//		- POR : Portamento Timing
//		- O : Opening
//	- NRPNs are supported as is; use NRPN and DTE operations.
//
// Implementation notes:
//
//	- The primary operations are "L" and "n".
//	  L defines a lyric handle, and n consumes a lyric to give a note.
//	  output. Both outputs a couple of meta texts and NRPN operations.
//	- Since both NRPNs from "L" and "n" should be actually unified to
//	  generate one note operation by the time NRPN(50,7F)=(7F,-) appears,
//	  this macro adds 1 step shifted (which should be almost harmess in
//	  480 base count) to make them consistent.
//

#basecount 480


// NRPNs
#variable __version:number = 0
#variable __device:number = 0
#variable __delay:number = 0
#macro VER_DEV_DELAY_VAL msb,vmsb,vlsb { \
	NRPN $msb,0 DTE $__version, $__device \
	NRPN $msb,1 DTE $__delay % #80, $__delay / #80 \
	NRPN $msb,2 DTE $vmsb,$vlsb }
#macro BANK val:number { VER_DEV_DELAY_VAL #60,$val,0 }
#macro V val:number { VER_DEV_DELAY_VAL #61,$val,0 }
#macro P val:number { VER_DEV_DELAY_VAL #62,$val,0 }
#macro VIB_RATE val:number { VER_DEV_DELAY_VAL #64,$val,0 }
#macro VIB_DEPTH val:number { VER_DEV_DELAY_VAL #65,$val,0 }
// FIXME: what is Effect2, which occupies #66?
#macro PITCH_BEND_SENSITIVITY val:number { VER_DEV_DELAY_VAL #67,$val,0 }
#macro @ prog:number, lang:number=0 { BANK $lang NRPN #53,2 DTE $prog,0 }

// Buffer definitions
#variable EntireText:buffer
#variable Common:buffer
#variable MasterTrackSetup:buffer
#variable Events:buffer
#variable Defs:buffer
#variable Handles:buffer
#variable PitchBendBPList:buffer
#variable PitchBendSensBPList:buffer
#variable DynamicsBPList:buffer
#variable EpRResidualBPList:buffer
#variable EpRESlopeBPList:buffer
#variable EpRESlopeDepthBPList:buffer
#variable EpRSineBPList:buffer
// They are renamed from 1-4 to A-D as numbers are invalid as an identifier character.
#variable ResoAFreqBPList:buffer
#variable ResoBFreqBPList:buffer
#variable ResoCFreqBPList:buffer
#variable ResoDFreqBPList:buffer
#variable ResoABWBPList:buffer
#variable ResoBBWBPList:buffer
#variable ResoCBWBPList:buffer
#variable ResoDBWBPList:buffer
#variable ResoAAmpBPList:buffer
#variable ResoBAmpBPList:buffer
#variable ResoCAmpBPList:buffer
#variable ResoDAmpBPList:buffer
#variable VibTremDepthBPList:buffer
#variable GenderFactorBPList:buffer
#variable PortamentTimingBPList:buffer
#variable OpeningBPList:buffer

#macro VSQ_INITIALIZE_MASTER { TRACKNAME "Master Track" }

#macro SETUP_COMMON { __STORE {"Common", "[Common]", \
	"\nVersion=", $CommonVersion, "\nName=", $CommonName, \
	"\nColor=", $CommonColorRed, ",", $CommonColorGreen, ",", $CommonColorBlue, \
	"\nDynamicsMode=", $CommonDynamicsMode, "\nPlayMode=", $CommonPlayMode, "\n" } }

#variable MasterFeder, MasterPanpot, MasterMute, MasterOutputMode, MasterTracks:number=1
#macro VSQ_SETUP_FIRST_TRACK { __STORE {"MasterTrackSetup", "[Master]", "\nPreMeasure=4\n", \
	"[Mixer]", "\nMasterFeder=", $MasterFeder, "\nMasterPanpot=", $MasterPanpot, \
	"\nMasterMute=", $MasterMute, "\nOutputMode=", $MasterOutputMode, \
	"\nTracks=", $MasterTracks } }

#variable __tmp_position
#macro OUTPUT_VSQ_TEXT { \
	__LET {"__tmp_position", $__timeline_position } \
	__LET {"__timeline_position", 0 } \
	SETUP_COMMON \
	__STORE { "EntireText", $Common, $MasterTrackSetup, "[EventList]\n", $Events, $Defs, $Handles \
		,$PitchBendBPList \
		,$PitchBendSensBPList \
		,$DynamicsBPList \
		,$EpRResidualBPList \
		,$EpRESlopeBPList \
		,$EpRESlopeDepthBPList \
		,$EpRSineBPList \
		,$ResoAFreqBPList \
		,$ResoBFreqBPList \
		,$ResoCFreqBPList \
		,$ResoDFreqBPList \
		,$ResoABWBPList \
		,$ResoBBWBPList \
		,$ResoCBWBPList \
		,$ResoDBWBPList \
		,$ResoAAmpBPList \
		,$ResoBAmpBPList \
		,$ResoCAmpBPList \
		,$ResoDAmpBPList \
		,$VibTremDepthBPList \
		,$GenderFactorBPList \
		,$PortamentTimingBPList \
		,$OpeningBPList \
		} \
	TEXT $EntireText \
	__LET {"__timeline_position", $__tmp_position } \
	}

#variable __handle_defs
#variable __handle_uses
#variable __events

// Singer definition ----
#variable IconID:string = "$07010000"
#variable IDS:string = "Miku"
#variable Original:number = 0
#variable Caption:string
#variable Length:number = 1
#variable Language:number = 0
#variable Program:number = 0
#variable CommonVersion:string = "DSB301"
#variable CommonName:string = "Voice1"
#variable CommonColorRed:number = 157
#variable CommonColorGreen:number = 181
#variable CommonColorBlue:number = 123
#variable CommonDynamicsMode:number = 0
#variable CommonPlayMode:number = 1

#macro SINGER_MIKU { \
	__LET {"IconID", "$07010000" } __LET {"IDS", "Miku" } __LET {"Original", 0} \
	__LET {"Language", 0 } __LET {"Program", 0 } __LET {"CommonVersion", "DSB301" } }
// FIXME: define SINGER_RIN, SINGER_LEN, SINGER_LUKA, SINGER_GAK, SINGER_MEG etc.

// relevant variables: $IconID, $IDS, $Original, $Caption, $Length, $Language, $Program
#macro DEFINE_SINGER { \
	__STORE { \
		"Handles", "[h#0000]\nIconID=", $IconID, "\nIDS=", $IDS, \
		"\nOriginal=", $Original, "\nCaption=", $Caption, "\nLength=", $Length, \
		"\nLanguage=", $Language, "\nProgram=", $Program, "\n" } \
	__STORE {"Events", "0=ID#0000\n"} \
	__STORE {"Defs", "[ID#0000]\nType=Singer\nIconHandle=", 0, "\n"} \
	@ $Program, $Language \
	__LET { "__handle_defs", $__handle_defs + 1 } \
	__LET { "__events", $__events + 1 } \
	}

#macro VSQ_INITIALIZE_TRACK { \
	r%1 \
	__STORE {"PitchBendBPList", "[PitchBendBPList]\n"} \
	__STORE {"PitchBendSensBPList", "[PitchBendSensBPList]\n"} \
	__STORE {"DynamicsBPList", "[DynamicsBPList]\n"} \
	__STORE {"EpRResidualBPList", "[EpRResidualBPList]\n"} \
	__STORE {"EpRESlopeBPList", "[EpRESlopeBPList]\n"} \
	__STORE {"EpRESlopeDepthBPList", "[EpRESlopeDepthBPList]\n"} \
	__STORE {"EpRSineBPList", "[EpRSineBPList]\n"} \
	__STORE {"ResoAFreqBPList", "[Reso1FreqBPList]\n"} \
	__STORE {"ResoBFreqBPList", "[Reso2FreqBPList]\n"} \
	__STORE {"ResoCFreqBPList", "[Reso3FreqBPList]\n"} \
	__STORE {"ResoDFreqBPList", "[Reso4FreqBPList]\n"} \
	__STORE {"ResoABWBPList", "[Reso1BWBPList]\n"} \
	__STORE {"ResoBBWBPList", "[Reso2BWBPList]\n"} \
	__STORE {"ResoCBWBPList", "[Reso3BWBPList]\n"} \
	__STORE {"ResoDBWBPList", "[Reso4BWBPList]\n"} \
	__STORE {"ResoAAmpBPList", "[Reso1AmpBPList]\n"} \
	__STORE {"ResoBAmpBPList", "[Reso2AmpBPList]\n"} \
	__STORE {"ResoCAmpBPList", "[Reso3AmpBPList]\n"} \
	__STORE {"ResoDAmpBPList", "[Reso4AmpBPList]\n"} \
	__STORE {"VibTremDepthBPList", "[VibTremDepthBPList]\n"} \
	__STORE {"GenderFactorBPList", "[GenderFactorBPList]\n"} \
	__STORE {"PortamentTimingBPList", "[PortamentTimingBPList]\n"} \
	__STORE {"OpeningBPList", "[OpeningBPList]\n"} \
	DEFINE_SINGER \
	}

#macro NRPNM val:number { CC #63,$val }
#macro NRPNL val:number { CC #62,$val }
#macro DTEM val:number { CC #06,$val }
#macro DTEL val:number { CC #26,$val }
#macro NRPNMP key,val { NRPNM $key DTEM $val }
#macro NRPNLP key,val { NRPNL $key DTEL $val }

#define HANDLE_DEFS_COND {$__handle_defs \> 10000 ? "[h#{0:D08}]\n", "[h#{0:D04}]\n"}
#macro L label:string, en:string, params:string, phonLen, phonA, phonB, phonC { \
	\// meta text
	__STORE_FORMAT {"Handles", HANDLE_DEFS_COND, $__handle_defs } \
	__STORE {"Handles", "L0=\"", $label, "\",\"", $en, "\",0.0000000,", $params, ",0\n"} \
	\// NRPNs (FIXME: they cannot be simply embedded at step 0.)
	NRPNM #50 NRPNLP #12,$phonLen NRPNLP #13,$phonA NRPNLP #14,$phonB NRPNLP #15,$phonC NRPNLP #4F,#7F \
	__LET{"__handle_defs", $__handle_defs + 1} }
// lyric macros are defined later (they are bunch).

// Vibrato operations ----
#variable vibrato:number = 0
#variable vibrato_constant:number = 0

#macro DEFINE_VIBRATO \
	ids:string="normal", caption:string, original:number=1, startRate:number, \
	startDepth:number, len:number, depthBPNum:number=0, rateBPNum:number=0 { \
	__STORE_FORMAT {"Handles", HANDLE_DEFS_COND, $__handle_defs } \
	__STORE {"Handles", "IconID=$04040001", "\nIDS=", $ids, "\nOriginal=", $original, \
		"\nCaption=", $caption, "\nLength=", $len, "\nStartDepth=", $startDepth, \
		"\nDepthBPNum=", $depthBPNum, "\nStartRate=", $startRate, \
		"\nRateBPNum=", $rateBPNum, "\n"} \
	__LET {"__handle_defs", $__handle_defs + 1 } \
	__LET {"__handle_uses", $__handle_defs } \
	}

#macro @V id:number { __LET { "vibrato", $id } } // ID is the defined order.
#macro @VV id:number { __LET {"vibrato_constant", $id } @V $id }

// Note operations ----
#variable dynamics:number = 0
#variable pm_bend_depth:number = 0
#variable pm_bend_length:number = 0
#variable pmb_portament_use:number = 0
#variable dem_dec_gain_rate:number = 0
#variable dem_accent:number = 0
#variable handle_uses:number = 0
#macro AddVibratoHandle id:number { __STORE{"EventDefs", "VibratoHandle=", $id } }
#define EVENTS_COND { $__events \> 10000 ? "[ID#{0:D08}]\n", "[ID#{0:D04}]\n" }
#define EVENTS_APPLY_COND $__events \> 10000 ? "{0}=ID#{1:D08}\n", "{0}=ID#{1:D04}\n"
#macro n key:number, step:length, gate:length, vel:number=$__velocity { \
	__LET{"__current_note_step", {$gate + %1} ? $gate, $step}  \
	__LET{"__current_note_gate", {{$__current_note_step * $__gate_rel * {1 / $__gate_rel_denom}}} - $__gate_abs} \
	__LET{"__current_note_gate", $__current_note_gate \< 0 ? 0, $__current_note_gate } \
	__STORE_FORMAT {"Defs", EVENTS_COND, $__events } \
	__STORE { "Defs", "Type=Anote\nLength=", $__current_note_gate, "\nNote=", $key, \
	"\nDynamics=", $dynamics, "\nPMBendDepth=", $pm_bend_depth, \
	"\nPMBendLength=", $pm_bend_length, "\nPMbPortamentUse=", \
	$pmb_portament_use, "\nDEMdecGainRate=", $dem_dec_gain_rate, \
	"\nDEMaccept=", $dem_accent, "\nLyricHandle=h#", $__handle_uses, "\n" } \
	__APPLY {$vibrato ? "AddVibratoHandle", "NOP", $vibrato} \
	__LET {"vibrato", $vibrato_constant } \
	__LET {"__handle_uses", $__handle_uses + 1 } \
	__STORE_FORMAT {"Events", EVENTS_APPLY_COND, $__timeline_position, $__events } \
	__LET { "__events", $__events + 1 } \
	\// NRPNs. FIXME: how to calculate "note location"?
	VER_DEV_DELAY_VAL#50,$key NRPNLP 3,$vel NRPNLP 4,$__current_note_gate NRPNLP 5,3 NRPNLP #7F,#7F \
	NOP $__current_note_step } // One note operation consumes one lyric handle

// BPLists ----
#macro BP_NRPN paraID,val { VER_DEV_DELAY #55,$paraID,0 NRPNLP 3,$val }

#variable __pitch_bend_bp:number
#macro B val:number { __LET { "__pitch_bend_bp", $val } __STORE { "PitchBendBPList", $__timeline_position, "=", $val, "\n" } \
	VER_DEV_DELAY #54, $val % #80, $val / #80 }
#macro B+ val:number { P $__pitch_bend_bp + $val }
#macro B_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "P", "P+", SPECTRA_ONESHOT_ARG_USE }

#variable __dynamics
#macro D val:number { __LET { "__dynamics", $val } \
	__STORE { "DynamicsBPList", $__timeline_position, "=", $val, "\n" } VER_DEV_DELAY #63,$val,0 }
#macro D+ val:number { D $__dynamics + $val }
#macro D_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "D", "D+", SPECTRA_ONESHOT_ARG_USE }

#variable __breathiness
#macro BRE val:number { __LET { "__breathiness", $val } \
	__STORE { "EpRResidualBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN31,$val }
#macro BRE+ val:number { BRE $__breathiness + $val }
#macro BRE_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "BRE", "BRE+", SPECTRA_ONESHOT_ARG_USE }

#variable __brightness
#macro BRI val:number { __LET { "__brightness", $val } \
	__STORE { "EpRESlopeBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN32,$val }
#macro BRI+ val:number { BRI $__brightness + $val }
#macro BRI_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "BRI", "BRI+", SPECTRA_ONESHOT_ARG_USE }

#variable __clearness
#macro C val:number { __LET { "__clearness", $val } \
	__STORE { "EpRESlopeDepthBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN33,$val }
#macro C+ val:number { C $__clearness + $val }
#macro C_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "C", "C+", SPECTRA_ONESHOT_ARG_USE }

// only in V1
#variable __harmonics
#macro H val:number { __LET { "__harmonics", $val } \
	__STORE { "EpRSineBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN30,$val }
#macro H+ val:number { H $__harmonics + $val }
#macro H_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "H", "H+", SPECTRA_ONESHOT_ARG_USE }

#variable __vib_trem_depth
// FIXME: no NRPNs to write?
#macro XD val:number { __LET { "__vib_trem_depth", $val } __STORE { "VibTremDepthBPList", $__timeline_position, "=", $val, "\n" } }
#macro XD+ val:number { XD $__vib_trem_depth + $val }
#macro XD_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "XD", "XD+", SPECTRA_ONESHOT_ARG_USE }

#variable __gender_factor
#macro G val:number { __LET { "__gender_factor", $val } \
	__STORE { "GenderFactorBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN70,$val }
#macro G+ val:number { G $__gender_factor + $val }
#macro G_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "G", "G+", SPECTRA_ONESHOT_ARG_USE }

#variable __portamento_timing
#macro POR val:number { __LET { "__portamento_timing", $val } \
	__STORE { "PortamentoTimingBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN34,$val }
#macro POR+ val:number { POR $__portamento_timing + $val }
#macro POR_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "POR", "POR+", SPECTRA_ONESHOT_ARG_USE }

#variable __opening
#macro O val:number { __LET { "__opening", $val } \
	__STORE { "OpeningBPList", $__timeline_position, "=", $val, "\n" } BP_NRPN35,$val }
#macro O+ val:number { O $__opening + $val }
#macro O_ SPECTRA_ONESHOT_ARG_DEF { SPECTRA_ONESHOT "O", "O+", SPECTRA_ONESHOT_ARG_USE }


// Lyrics macro ----
#macro あ en:string="a",params:string="0" { L "あ",$en,$params }
#macro い en:string="i",params:string="0" { L "い",$en,$params }
#macro う en:string="M",params:string="0" { L "う",$en,$params }
#macro え en:string="e",params:string="0" { L "え",$en,$params }
#macro お en:string="o",params:string="0" { L "お",$en,$params }
#macro か en:string="k a",params:string="64,0" { L "か",$en,$params }
#macro き en:string="k' i",params:string="64,0" { L "き",$en,$params }
#macro く en:string="k M",params:string="64,0" { L "く",$en,$params }
#macro け en:string="k e",params:string="64,0" { L "け",$en,$params }
#macro こ en:string="k o",params:string="64,0" { L "こ",$en,$params }
#macro が en:string="g a",params:string="64,0" { L "が",$en,$params }
#macro ぎ en:string="g' i",params:string="64,0" { L "ぎ",$en,$params }
#macro ぐ en:string="g M",params:string="64,0" { L "ぐ",$en,$params }
#macro げ en:string="g e",params:string="64,0" { L "げ",$en,$params }
#macro ご en:string="g o",params:string="64,0" { L "ご",$en,$params }
#macro んが en:string="N a",params:string="64,0" { L "んが",$en,$params }
#macro んぎ en:string="N' i",params:string="64,0" { L "んぎ",$en,$params }
#macro んぐ en:string="N M",params:string="64,0" { L "んぐ",$en,$params }
#macro んげ en:string="N e",params:string="64,0" { L "んげ",$en,$params }
#macro んご en:string="N o",params:string="64,0" { L "んご",$en,$params }
#macro さ en:string="s a",params:string="64,0" { L "さ",$en,$params }
#macro し en:string="S i",params:string="64,0" { L "し",$en,$params }
#macro す en:string="s M",params:string="64,0" { L "す",$en,$params }
#macro せ en:string="s e",params:string="64,0" { L "せ",$en,$params }
#macro そ en:string="s o",params:string="64,0" { L "そ",$en,$params }
#macro ざ en:string="z a",params:string="64,0" { L "ざ",$en,$params }
#macro じ en:string="Z i",params:string="64,0" { L "じ",$en,$params }
#macro ず en:string="z M",params:string="64,0" { L "ず",$en,$params }
#macro ぜ en:string="z e",params:string="64,0" { L "ぜ",$en,$params }
#macro ぞ en:string="z o",params:string="64,0" { L "ぞ",$en,$params }
#macro _ざ en:string="dz a",params:string="64,0" { L "ざ",$en,$params }	// 単語の始め
#macro _じ en:string="dZ i",params:string="64,0" { L "じ",$en,$params }
#macro _ず en:string="dz M",params:string="64,0" { L "ず",$en,$params }
#macro _ぜ en:string="dz e",params:string="64,0" { L "ぜ",$en,$params }
#macro _ぞ en:string="dz o",params:string="64,0" { L "ぞ",$en,$params }
#macro た en:string="t a",params:string="64,0" { L "た",$en,$params }
#macro てぃ en:string="t i",params:string="64,0" { L "てぃ",$en,$params }
#macro ち en:string="tS i",params:string="64,0" { L "ち",$en,$params }
#macro つ en:string="ts M",params:string="64,0" { L "つ",$en,$params }
#macro て en:string="t e",params:string="64,0" { L "て",$en,$params }
#macro と en:string="t o",params:string="64,0" { L "と",$en,$params }
#macro だ en:string="d a",params:string="64,0" { L "だ",$en,$params }
#macro ぢ en:string="Z i",params:string="64,0" { L "ぢ",$en,$params }
#macro づ en:string="z M",params:string="64,0" { L "づ",$en,$params }
#macro でぃ en:string="d' i",params:string="64,0" { L "でぃ",$en,$params }
#macro どぅ en:string="d M",params:string="64,0" { L "どぅ",$en,$params }
#macro で en:string="d e",params:string="64,0" { L "で",$en,$params }
#macro ど en:string="d o",params:string="64,0" { L "ど",$en,$params }
#macro な en:string="n a",params:string="64,0" { L "な",$en,$params }
#macro に en:string="J i",params:string="64,0" { L "に",$en,$params }
#macro ぬ en:string="n M",params:string="64,0" { L "ぬ",$en,$params }
#macro ね en:string="n e",params:string="64,0" { L "ね",$en,$params }
#macro の en:string="n o",params:string="64,0" { L "の",$en,$params }
#macro は en:string="h\\ a",params:string="64,0" { L "は",$en,$params }	// 単語の途中
#macro ひ en:string="C i",params:string="64,0" { L "ひ",$en,$params }
#macro ふぃ en:string="p\\' i",params:string="64,0" { L "ふぃ",$en,$params }
#macro ふ en:string="p\\ M",params:string="64,0" { L "ふ",$en,$params }
#macro へ en:string="h\\ e",params:string="64,0" { L "へ",$en,$params }
#macro ほ en:string="h\\ o",params:string="64,0" { L "ほ",$en,$params }
#macro _は en:string="h a",params:string="64,0" { L "は",$en,$params }	// (単語の始め)
#macro _ひ en:string="C i",params:string="64,0" { L "ひ",$en,$params }
#macro _ふぃ en:string="p\\' i",params:string="64,0" { L "ふぃ",$en,$params }
#macro _ふ en:string="p\\ M",params:string="64,0" { L "ふ",$en,$params }
#macro _へ en:string="h e",params:string="64,0" { L "へ",$en,$params }
#macro _ほ en:string="h o",params:string="64,0" { L "ほ",$en,$params }
#macro ば en:string="b a",params:string="64,0" { L "ば",$en,$params }
#macro び en:string="b' i",params:string="64,0" { L "び",$en,$params }
#macro ぶ en:string="b M",params:string="64,0" { L "ぶ",$en,$params }
#macro べ en:string="b e",params:string="64,0" { L "べ",$en,$params }
#macro ぼ en:string="b o",params:string="64,0" { L "ぼ",$en,$params }
#macro ぱ en:string="p a",params:string="64,0" { L "ぱ",$en,$params }
#macro ぴ en:string="p' i",params:string="64,0" { L "ぴ",$en,$params }
#macro ぷ en:string="p M",params:string="64,0" { L "ぷ",$en,$params }
#macro ぺ en:string="p e",params:string="64,0" { L "ぺ",$en,$params }
#macro ぽ en:string="p o",params:string="64,0" { L "ぽ",$en,$params }
#macro ま en:string="m a",params:string="64,0" { L "ま",$en,$params }
#macro み en:string="m' i",params:string="64,0" { L "み",$en,$params }
#macro む en:string="m M",params:string="64,0" { L "む",$en,$params }
#macro め en:string="m e",params:string="64,0" { L "め",$en,$params }
#macro も en:string="m o",params:string="64,0" { L "も",$en,$params }
#macro や en:string="j a",params:string="64,0" { L "や",$en,$params }
#macro ゆ en:string="j u",params:string="64,0" { L "ゆ",$en,$params }
#macro よ en:string="j o",params:string="64,0" { L "よ",$en,$params }
#macro ら en:string="4 a",params:string="64,0" { L "ら",$en,$params }
#macro り en:string="4' i",params:string="64,0" { L "り",$en,$params }
#macro る en:string="4 M",params:string="64,0" { L "る",$en,$params }
#macro れ en:string="4 e",params:string="64,0" { L "れ",$en,$params }
#macro ろ en:string="4 o",params:string="64,0" { L "ろ",$en,$params }
#macro わ en:string="w a",params:string="64,0" { L "わ",$en,$params }
#macro を en:string="o",params:string="0" { L "を",$en,$params }
// FIXME: define ん

